<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Story Editor</title>
  <!-- <author>KryptykAngel</author> -->
  <!-- <version>Version 2.0</version> -->
  <link rel="manifest" href="manifest.json" />
  <script src="https://unpkg.com/dexie@3/dist/dexie.js"></script>
    <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background-color: #121212;
      color: #f0f0f0;
      display: flex;
      flex-direction: column;
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden;
    }
    #header {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #333;
      background-color: #121212;
      z-index: 10; 
    }
    #header button {
      background-color: #333;
      color: #f0f0f0;
      border: none;
      padding: 0.5rem 1rem;
      margin-right: 0.5rem;
      cursor: pointer;
      border-radius: 4px;
      font-size: 1rem;
    }
    #header button#collectionToggleBtn {
        color: #f0f0f0;
    }
    #header button#modeToggleBtn { 
        color: #f0f0f0;
    }

    #contentWrap {
      flex: 1;
      display: flex;
      position: relative; 
      overflow-x: hidden; 
    }

    /* Left Sidebar - Base Styles */
    #sidebar {
      width: 50%;
      max-width: 500px;
      flex-shrink: 0;
      background-color: #1e1e1e;
      padding: 0;
      display: none; 
      flex-direction: column;
      position: relative; 
      order: 1;
      border-right: 1px solid #333; 
    }

    /* Right Sidebar (Collection) - Base Styles */
    #collectionSidebar {
        width: 50%;
        max-width: 500px;
        flex-shrink: 0;
        background-color: #1e1e1e;
        padding: 0;
        display: none; 
        flex-direction: column;
        position: relative; 
        order: 3;
        border-left: 1px solid #333; 
    }

    #sidebarHeader, #collectionSidebarHeader { 
      background-color: #1e1e1e;
      z-index: 5; 
      padding: 1rem 1rem 0.5rem 1rem;
      border-bottom: 1px solid #333;
    }
    #sidebarStats, #collectionSidebarStats { 
      margin-bottom: 0.5rem;
    }
    #cardCountEl, #collectionCardCount { /* Renamed cardCount to cardCountEl in HTML for consistency */
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }
     #sidebarStatsTopRow { 
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
    }
    #viewStoryBtn {
        padding: 0.25rem 0.5rem;
        font-size: 0.8rem;
        background-color: #444;
        color: #f0f0f0;
        border: 1px solid #555;
        border-radius: 3px;
        cursor: pointer;
    }
    #cardFilter, #cardSort, #collectionCardFilter, #collectionCardSort, #sidebarSelectAllContainer { 
      width: 100%; 
      box-sizing: border-box; 
      margin-bottom: 0.5rem;
      padding: 0.3rem;
      background: #1e1e1e;
      color: #f0f0f0;
      border: 1px solid #333;
      border-radius: 3px;
    }
    #sidebarSelectAllContainer { /* Specific for the container of select all */
        padding: 0; /* Remove padding if it's just a container */
        border: none; /* No border for the container itself */
        background: transparent;
    }
    #cardSort, #collectionCardSort {
        padding: 0.3rem; /* Ensure select has padding */
    }
    .cardListHeader {
      display: grid;
      grid-template-columns: 1fr 60px 40px;
      font-size: var(--sidebar-font-size, 14px);
      font-weight: bold;
      padding: 0.25rem 0.5rem;
      border-top: 1px solid #333;
      border-bottom: 1px solid #333;
      text-align: left;
    }
    .colTitle {
      padding-right: 0.5rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .colType {
      width: 60px;
      text-align: left;
      font-size: var(--type-font-size, 14px);
      display: inline-block; 
    }
    .colChars {
      width: 40px;
      text-align: right; 
      font-size: var(--char-font-size, 14px);
      display: inline-block;
    }
    #cardList, #collectionCardList, #jsonTreeView { 
      flex-grow: 1;
      overflow-y: auto;
    }
   #jsonTreeView {
        padding: 0.5rem;
        font-family: monospace;
        font-size: var(--json-tree-font-size, 0.875rem); /* Use CSS variable, 0.875rem is ~14px if base is 16px, or use px like 12px */
        display: none;
    }
    .json-tree-item {
        margin-left: 15px;
        cursor: default;
        user-select: none; /* Prevent text selection on keys */
    }
    .json-tree-item.collapsible > .json-key::before {
        content: '▶ '; 
        cursor: pointer;
    }
     .json-tree-item.collapsible.expanded > .json-key::before {
        content: '▼ '; 
    }
    .json-key {
        color: #9cdcfe; 
        cursor: pointer;
    }
    .json-key:hover {
        text-decoration: underline;
    }
    .json-value-container { /* Container for the value part if needed for styling */
        /* No specific styles needed for now */
    }
    .json-value {
        color: #ce9178; 
    }
    .json-value.number {
        color: #b5cea8; 
    }
    .json-value.boolean {
        color: #569cd6; 
    }
    .json-value.null {
        color: #569cd6; 
    }
    .json-placeholder {
        color: #808080; 
        font-style: italic;
    }
    .cardItem {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0.5rem;
      border-bottom: 1px solid #333;
      font-size: var(--sidebar-font-size, 14px);
    }
    .cardRow {
      display: grid;
      grid-template-columns: 1fr 60px 40px;
      gap: 0.5rem;
      cursor: pointer;
      align-items: center;
      flex-grow: 1;
    }
    .cardTitle {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: left;
    }
    .cardTitle.active-card {
        font-weight: bold;
    }
    .cardTitle.active-card::before {
        content: "* ";
    }
    .cardType {
      font-size: var(--type-font-size, 14px);
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
    }
    .cardLength {
      font-size: var(--char-font-size, 14px);
      text-align: left; 
    }
    #batchActions, #collectionBatchActions {
      background-color: #1e1e1e;
      padding: 0.5rem;
      border-top: 1px solid #333;
      text-align: center;
      display: flex;
      gap: 0.5rem;
      justify-content: center;
    }
    #batchActions button, #collectionBatchActions button {
      background-color: #333;
      color: #f0f0f0;
      border: none;
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    /* Main Content Area - Base Styles */
    #main {
      flex-grow: 1;
      flex-shrink: 1;
      flex-basis: 0;
      display: flex;
      flex-direction: column;
      padding: 1rem;
      overflow-y: auto;
      order: 2;
      min-width: 200px; 
    }
    #main #storyJsonEditor { 
        width: 100%;
        height: calc(var(--vh, 1vh) * 80); 
        box-sizing: border-box;
        background: #1e1e1e;
        color: #f0f0f0;
        border: 1px solid #333;
        padding: 0.5rem;
        font-size: var(--editor-font-size, 14px);
        border-radius: 3px;
        resize: vertical;
        display: none; 
        white-space: pre-wrap; 
        overflow-wrap: break-word;
        font-family: monospace;
    }
    #editor { /* Container for card editing fields */
        display: flex;
        flex-direction: column; /* Ensures children stack vertically */
    }
    #editor input,
    #editor select,
    #editor textarea {
      width: 100%; 
      box-sizing: border-box; 
      margin-bottom: 0.5rem;
      background: #1e1e1e;
      color: #f0f0f0;
      border: 1px solid #333;
      padding: 0.5rem;
      font-size: var(--editor-font-size, 14px);
      border-radius: 3px;
    }
    #editCustomType {
      display: none;
    }
    #charCount { 
      text-align: right;
      font-size: 0.9rem;
      color: #aaa;
      margin-bottom: 0.5rem;
    }
    .inlineCheckbox {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 0.85rem;
      white-space: nowrap;
      margin-bottom: 0.5rem;
    }
    #valueEditor, #editDescription {
      min-height: 200px;
      height: calc(var(--vh, 1vh) * 30);
      resize: vertical;
    }
    #editor .button-group {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }
    #editor .button-group button {
        flex-grow: 0; 
        background-color: #333; 
        color: white;
    }
    #editor #cancelChangesBtn { 
        width:100%;
        background-color: #dc3545; 
        color:white;
        margin-top: 0.5rem; 
    }
    #editor button[onclick="addCurrentCardToCollection()"] { 
        background-color: #28a745; 
        color: white;
    }


    .collection-io-buttons {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
    }
    .collection-io-buttons button {
        flex:1;
        background-color: #007bff;
        color: white;
        border: none;
        padding: 0.5rem; 
        border-radius: 4px;
        font-size: 0.7rem;
        cursor: pointer;
    }
    .collection-io-buttons button:hover {
        background-color: #0056b3;
    }

    .workspace-io-buttons {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem; 
        margin-bottom: 0.5rem;
    }
    .workspace-io-buttons button {
        flex: 1; 
        background-color: #007bff; 
        color: white;
        border: none; 
        padding: 0.5rem; 
        border-radius: 4px; 
        font-size: 0.7rem; 
        cursor: pointer;
    }
    .workspace-io-buttons button:hover {
        background-color: #0056b3; 
    }
    .workspace-io-buttons button#exportBtn.disabled { 
        background-color: #808080; 
        cursor: not-allowed;
    }

    #settingsOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: calc(var(--vh, 1vh) * 100);
      background: rgba(0, 0, 0, 0.85);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
    }
    #settingsPanel {
      background: #2a2a2a;
      padding: 2rem;
      border: 1px solid #444;
      border-radius: 8px;
      width: 90%;
      max-width: 450px;
    }
    #settingsPanel h2 {
        margin-top: 0;
        color: #00acc1;
    }
    #settingsPanel label {
      display: block;
      margin: 0.75rem 0 0.25rem;
      font-size: 0.95rem;
    }
    #settingsPanel input[type="number"], #settingsPanel input[type="checkbox"] {
        margin-right: 0.5rem; 
    }
    #settingsPanel button {
        margin-top: 1.5rem;
        padding: 0.6rem 1.2rem;
        background-color: #007bff; 
        color: white;
        border:none;
        border-radius: 4px;
        cursor: pointer;
    }
    #settingsPanel button + button {
        margin-left: 0.5rem;
        background-color: #555;
    }

    label {
      display: block;
      margin: 0.3rem 0 0.3rem;
    }

    @media (max-width: 768px) {
        #sidebar, #collectionSidebar {
            position: relative; 
            height: 100%;    
            overflow-y: auto;
            z-index: 5;      
            box-shadow: none;
            flex-shrink: 0;  
        }
        #sidebar {
            border-right: 1px solid #333; 
        }
        #sidebar:not([style*="display: flex"]) { 
             border-right: none;
        }
        #collectionSidebar {
            border-left: 1px solid #333; 
        }
        #collectionSidebar:not([style*="display: flex"]) { 
             border-left: none;
        }
        #main {
            flex-grow: 1;     
            min-width: 50px;  
            width: auto;      
            z-index: 1;       
            overflow-y: auto; 
        }
        body.mobile-both-sidebars-open #sidebar,
        body.mobile-both-sidebars-open #collectionSidebar {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 15; 
            box-shadow: 0px 0px 15px rgba(0,0,0,0.5);
        }
        body.mobile-both-sidebars-open #sidebar {
            left: 0;
            border-right: none; 
        }
        body.mobile-both-sidebars-open #collectionSidebar {
            right: 0;
            border-left: none; 
        }
        body.mobile-both-sidebars-open #main {
            position: absolute; 
            width: 100%;      
            height: 100%;     
            left: 0;
            top: 0;
            z-index: 1;       
            min-width: 0;     
        }
    }
  </style>  
</head>
<body>
  <div id="header">
    <button id="cardListToggle">☰</button>
    <h1 id="appTitle" style="flex:1; font-size:1.2rem;">Story Card Editor</h1>
    <button id="modeToggleBtn">Story Editor</button> 
    <button id="settingsBtn">⚙️</button>
    <button id="collectionToggleBtn">★</button>
    <input type="file" id="fileInput" accept="application/json" style="display:none" />
    <input type="file" id="collectionFileInput" accept="application/json" style="display:none" /> 
  </div>

  <div id="contentWrap">
    <div id="sidebar"> 
      <div id="sidebarHeader">
            <div id="sidebarStats">
                <div id="sidebarStatsTopRow"> 
                    <div id="cardCountEl">Total Cards: 0</div>
                    <button id="viewStoryBtn" style="display:none;">View Story</button> 
                </div>
                <div class="workspace-io-buttons">
                    <button id="importBtn">Import Cards</button> 
                    <button id="exportBtn">Export Cards</button> 
                </div>
                <input id="cardFilter" placeholder="Filter by title/type/value..." />
                <select id="cardSort">
                    <option value="default" selected>Sort: Default</option>
                    <option value="title">Sort: Title</option>
                    <option value="type">Sort: Type</option>
                    <option value="length">Sort: Character Count</option>
                </select>
                <div id="sidebarSelectAllContainer" style="margin: 0.5rem 0;">
                    <label style="font-size: 0.85rem;">
                        <input type="checkbox" id="selectAllBox" />
                        Select All
                    </label>
                </div>
            </div>
            <div class="cardListHeader">
                <span class="colTitle">Name</span>
                <span class="colType" id="typeHeader">Type</span>
                <span class="colChars" id="charsHeader">Chars</span>
            </div>
        </div>
        <div id="cardList"></div> 
        <div id="jsonTreeView" style="display:none;"></div> 
        <div id="batchActions">
            <button onclick="deleteSelected()">Delete</button>
            <button onclick="assignTypeSelected()">Set Type</button>
            <button onclick="addSelectedWorkspaceCardsToCollection()">Add to Collection</button>
        </div>
    </div>

    <div id="main">
        <div id="editor"> 
            <input id="editTitle" placeholder="Title" />
            <input id="editKeys" placeholder="Keys / Triggers" />
            <select id="editType">
                <option value="character">character</option>
                <option value="class">class</option>
                <option value="race">race</option>
                <option value="location">location</option>
                <option value="faction">faction</option>
                <option value="custom">custom</option>
                <option value="equipment">equipment</option>
                <option value="creature">creature</option>
                <option value="container">container</option>
            </select>
            <input id="editCustomType" placeholder="Enter custom type..." />
            <div class="inlineCheckbox">
                Use for Character Creation
                <input type="checkbox" id="editUseForCC" />
            </div>
            <textarea id="valueEditor" placeholder="Edit card value here..."></textarea>
            <div id="charCount">Character Count: 0</div>
            <textarea id="editDescription" placeholder="Description / Notes"></textarea>
            <div class="button-group"> <button onclick="saveCard()">Save Card</button>
                <button onclick="saveAsNewCard()">Save As New Card</button>
                <button onclick="deleteCurrentCard()">Delete Card</button>
            </div>
            <div id="unsavedChangesMessage" style="color: red; margin-top: 0.5rem; height: 1.2em;"></div>
            <button id="cancelChangesBtn" onclick="cancelChanges()" style="margin-top: 0.5rem; display: none; width:100%; background-color: #dc3545; color:white;">Cancel Changes</button>
        </div>
        <textarea id="storyJsonEditor" style="display:none;" readonly></textarea> 
    </div>

    <div id="collectionSidebar"> 
      <div id="collectionSidebarHeader">
            <div id="collectionSidebarStats">
                <div id="collectionCardCount">Total Collection Cards: 0</div>
                <div class="collection-io-buttons"> 
                    <button onclick="importCollectionJSON()">Import Collection</button>
                    <button onclick="exportCollectionJSON()">Export Collection</button>
                </div>
                <input id="collectionCardFilter" placeholder="Filter collection..." />
                <select id="collectionCardSort">
                    <option value="default" selected>Sort: Default</option>
                    <option value="title">Sort: Title</option>
                    <option value="type">Sort: Type</option>
                    <option value="length">Sort: Character Count</option>
                </select>
                <div style="margin: 0.5rem 0;">
                    <label style="font-size: 0.85rem;">
                        <input type="checkbox" id="collectionSelectAllBox" />
                        Select All
                    </label>
                </div>
            </div>
            <div class="cardListHeader">
                <span class="colTitle">Name</span>
                <span class="colType" id="collectionTypeHeader">Type</span>
                <span class="colChars" id="collectionCharsHeader">Chars</span>
            </div>
        </div>
        <div id="collectionCardList"></div>
        <div id="collectionBatchActions">
            <button onclick="deleteSelectedFromCollection()">Delete</button>
            <button onclick="addSelectedToWorkspace()">Add to Workspace</button>
        </div>
    </div>
  </div>

  <div id="settingsOverlay">
    <div id="settingsPanel">
      <h2>Settings</h2>
      <label for="sidebarFont">Sidebar Font Size (px)</label>
      <input type="number" id="sidebarFont" min="10" max="24" value="14" />
      <label for="editorFont">Editor Font Size (px)</label>
      <input type="number" id="editorFont" min="10" max="24" value="14" />
      <label for="charFont">Sidebar Character Count Font Size (px)</label>
      <input type="number" id="charFont" min="10" max="24" value="14" />
      <label for="typeFont">Sidebar Type Column Font Size (px)</label>
      <input type="number" id="typeFont" min="10" max="24" value="14" />
      <label for="jsonTreeFont">JSON Tree Font Size (px)</label>
      <input type="number" id="jsonTreeFont" min="8" max="20" value="12" />
      <label><input type="checkbox" id="settingShowChars" checked /> Show Character Count Column in Sidebars</label>
      <label><input type="checkbox" id="settingShowType" checked /> Show Type Column in Sidebars</label>
      <label><input type="checkbox" id="settingTapToClose" /> Tapping outside active sidebar hides it</label>
      <button onclick="saveSettings()">Save & Close</button>
      <button onclick="toggleSettings(false)" style="margin-top: 0.5rem;">Close Without Saving</button>
    </div>
  </div>

  <script>
    // --- Polyfills and Setup ---
    function setVisualViewportHeight() {
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    window.addEventListener('resize', setVisualViewportHeight);
    window.addEventListener('orientationchange', setVisualViewportHeight);
    setVisualViewportHeight();

    // --- Global State & DOM References (Workspace) ---
    let cards = []; 
    let currentCardIndex = null; 
    let currentFileName = "story_cards.json"; 
    const selectedCardIndexes = new Set(); 
    let originalCardData = null; 
    let unsavedChangesMap = new Map(); 

    let editorCardSource = null; 
    let editorCardDbId = null;   
    let editorWorkspaceIndex = null; 

    let currentEditorMode = 'cardEditor'; 
    let currentStoryView = 'cards'; 
    let importedStoryData = null; 

    const sidebar = document.getElementById('sidebar');
    const cardListDiv = document.getElementById('cardList');
    const cardFilter = document.getElementById('cardFilter');
    const cardSort = document.getElementById('cardSort');
    const cardCountEl = document.getElementById('cardCountEl'); 
    const selectAllBox = document.getElementById('selectAllBox');
    const sidebarSelectAllContainer = document.getElementById('sidebarSelectAllContainer');
    const typeHeader = document.getElementById('typeHeader'); 
    const charsHeader = document.getElementById('charsHeader'); 
    const cardListHeaderForSidebar = document.querySelector('#sidebar .cardListHeader');
    const main = document.getElementById('main'); 
    const appTitle = document.getElementById('appTitle');
    const modeToggleBtn = document.getElementById('modeToggleBtn');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const viewStoryBtn = document.getElementById('viewStoryBtn');
    const jsonTreeView = document.getElementById('jsonTreeView');
    const storyJsonEditor = document.getElementById('storyJsonEditor');
    const editorDiv = document.getElementById('editor'); 
    const batchActionsDiv = document.getElementById('batchActions'); 
    
    // Editor DOM Elements
    const valueEditor = document.getElementById('valueEditor');
    const editDescription = document.getElementById('editDescription');
    const editorCharCount = document.getElementById('charCount'); 
    const editTitle = document.getElementById('editTitle');
    const editKeys = document.getElementById('editKeys');
    const editType = document.getElementById('editType');
    const editCustomType = document.getElementById('editCustomType');
    const editUseForCC = document.getElementById('editUseForCC');
    const unsavedChangesMessage = document.getElementById('unsavedChangesMessage');
    const cancelChangesBtn = document.getElementById('cancelChangesBtn');

    const fileInput = document.getElementById('fileInput');
    const collectionFileInput = document.getElementById('collectionFileInput'); 

    let collectionCards = []; 
    const selectedCollectionCardDBIds = new Set(); 

    const collectionSidebar = document.getElementById('collectionSidebar');
    const collectionCardListDiv = document.getElementById('collectionCardList');
    const collectionCardFilter = document.getElementById('collectionCardFilter');
    const collectionCardSort = document.getElementById('collectionCardSort');
    const collectionCardCountEl = document.getElementById('collectionCardCount'); 
    const collectionSelectAllBox = document.getElementById('collectionSelectAllBox');
    const collectionToggleBtn = document.getElementById('collectionToggleBtn');
    const collectionTypeHeader = document.getElementById('collectionTypeHeader');
    const collectionCharsHeader = document.getElementById('collectionCharsHeader');

    const db = new Dexie("StoryCardCollectionDB");
    db.version(1).stores({
        collection: '++id, title, type, originalIndex'
    });

    function getEditorData() {
      return {
        title: editTitle.value.trim(),
        keys: editKeys.value.trim(),
        description: editDescription.value.trim(),
        useForCharacterCreation: editUseForCC.checked,
        value: valueEditor.value.trim(),
        type: (editType.value === 'custom') ? (editCustomType.value.trim() || 'custom') : editType.value,
      };
    }

    function updateMobileLayout() {
        const body = document.body;
        const isDesktop = window.innerWidth > 768;
        body.classList.remove('mobile-left-sidebar-open', 'mobile-right-sidebar-open', 'mobile-both-sidebars-open');
        sidebar.style.position = ''; sidebar.style.left = ''; sidebar.style.zIndex = ''; sidebar.style.boxShadow = '';
        collectionSidebar.style.position = ''; collectionSidebar.style.right = ''; collectionSidebar.style.zIndex = ''; collectionSidebar.style.boxShadow = '';
        main.style.position = ''; main.style.width = ''; main.style.left = ''; main.style.top = ''; main.style.height = ''; main.style.zIndex = ''; main.style.minWidth = ''; 
        if (isDesktop) return;
        const isLeftOpen = sidebar.style.display === 'flex';
        const isRightOpen = collectionSidebar.style.display === 'flex';
        if (isLeftOpen && isRightOpen) body.classList.add('mobile-both-sidebars-open');
        else if (isLeftOpen) body.classList.add('mobile-left-sidebar-open');
        else if (isRightOpen) body.classList.add('mobile-right-sidebar-open');
    }
    
    modeToggleBtn.onclick = () => {
        if (currentEditorMode === 'cardEditor') {
            currentEditorMode = 'storyEditor';
            modeToggleBtn.textContent = 'Card Editor';
            appTitle.textContent = 'Story Editor';
            cardCountEl.textContent = 'Total Cards: 0 (0)';
            importBtn.textContent = 'Import Story';
            exportBtn.textContent = 'Export Story';
            exportBtn.classList.add('disabled'); 
            viewStoryBtn.style.display = 'inline-block'; 
            viewStoryBtn.textContent = 'View Story'; 
            currentStoryView = 'cards'; 
            clearEditorAndState(); 
            cards = []; 
            importedStoryData = null; 
            updateUIForStoryEditorMode(); 
            renderSidebar(); 
        } else {
            currentEditorMode = 'cardEditor';
            modeToggleBtn.textContent = 'Story Editor';
            appTitle.textContent = 'Story Card Editor';
            importBtn.textContent = 'Import Cards';
            exportBtn.textContent = 'Export Cards';
            exportBtn.classList.remove('disabled'); 
            viewStoryBtn.style.display = 'none'; 
            clearEditorAndState(); 
            cards = []; 
            importedStoryData = null;
            updateUIForCardEditorMode();
            renderSidebar(); 
        }
    };

    function updateUIForStoryEditorMode() { 
        editorDiv.style.display = 'none'; 
        storyJsonEditor.style.display = 'none'; 
        
        cardFilter.style.display = 'block';
        cardSort.style.display = 'block';
        sidebarSelectAllContainer.style.display = 'block';
        if (cardListHeaderForSidebar) cardListHeaderForSidebar.style.display = 'grid';
        cardListDiv.style.display = 'block'; 
        jsonTreeView.style.display = 'none'; 
        batchActionsDiv.style.display = 'flex'; 
    }

    function updateUIForCardEditorMode() {
        editorDiv.style.display = 'flex'; 
        editorDiv.style.flexDirection = 'column'; 
        storyJsonEditor.style.display = 'none'; 
        
        cardFilter.style.display = 'block';
        cardSort.style.display = 'block';
        sidebarSelectAllContainer.style.display = 'block';
        if (cardListHeaderForSidebar) cardListHeaderForSidebar.style.display = 'grid';
        cardListDiv.style.display = 'block';
        jsonTreeView.style.display = 'none';
        batchActionsDiv.style.display = 'flex';
        cardCountEl.textContent = `Total Cards: ${cards.length} (Showing: ${getVisibleCardsCount()})`;
    }
    
    viewStoryBtn.onclick = () => {
        toggleViewStoryOrCards();
    };

    function toggleViewStoryOrCards() {
        if (currentStoryView === 'cards') {
            currentStoryView = 'story';
            viewStoryBtn.textContent = 'View Cards';
            editorDiv.style.display = 'none'; 
            storyJsonEditor.style.display = 'block'; 
            storyJsonEditor.value = importedStoryData ? "Click an item in the tree (sidebar) to view its value, or switch to 'View Cards' to see story cards." : "Import a story to see its content.";

            cardFilter.style.display = 'none';
            cardSort.style.display = 'none';
            sidebarSelectAllContainer.style.display = 'none';
            if (cardListHeaderForSidebar) cardListHeaderForSidebar.style.display = 'none';
            cardListDiv.style.display = 'none'; 
            batchActionsDiv.style.display = 'none'; 

            jsonTreeView.style.display = 'block'; 
            renderJsonTreeView(importedStoryData);

        } else { 
            currentStoryView = 'cards';
            viewStoryBtn.textContent = 'View Story';
            editorDiv.style.display = 'none'; 
            storyJsonEditor.style.display = 'none'; 

            cardFilter.style.display = 'block';
            cardSort.style.display = 'block';
            sidebarSelectAllContainer.style.display = 'block';
            if (cardListHeaderForSidebar) cardListHeaderForSidebar.style.display = 'grid';
            cardListDiv.style.display = 'block'; 
            batchActionsDiv.style.display = 'flex'; 
            
            jsonTreeView.style.display = 'none'; 
            renderSidebar(); 
        }
    }

    function renderJsonTreeView(jsonData) {
        jsonTreeView.innerHTML = ''; 
        if (jsonData) {
            const rootKeyName = jsonData?.data?.scenario?.title || jsonData?.data?.adventure?.title || "Story Data";
            const tree = createJsonTreeElement(jsonData, rootKeyName, true, '');
            jsonTreeView.appendChild(tree);
        } else {
            jsonTreeView.textContent = "No story data loaded.";
        }
    }
    
    function createJsonTreeElement(data, keyName = null, isInitialCall = true, currentPath = '') {
        const item = document.createElement('div');
        item.className = 'json-tree-item';
    
        const keySpan = document.createElement('span');
        keySpan.className = 'json-key';
        keySpan.textContent = `${keyName}: `;
        item.appendChild(keySpan);
        
        let childrenContainer; 
    
        keySpan.addEventListener('click', (e) => {
            storyJsonEditor.value = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
            storyJsonEditor.scrollTop = 0;
        });
    
        if (typeof data === 'object' && data !== null) {
            item.classList.add('collapsible');
            childrenContainer = document.createElement('div'); 
            childrenContainer.className = 'json-children';
            
            let expandThisLevel = false;
            if (isInitialCall) { 
                expandThisLevel = true;
            } else if (currentPath === '' && keyName === 'data') { 
                expandThisLevel = true;
            } else if (currentPath === 'data' && (keyName === 'scenario' || keyName === 'adventure')) { 
                expandThisLevel = true;
            }
    
            childrenContainer.style.display = expandThisLevel ? 'block' : 'none'; 
            if(expandThisLevel) item.classList.add('expanded');
    
            const newPathForChildren = isInitialCall ? '' : (currentPath ? currentPath + '.' + keyName : keyName);
    
            for (const key in data) {
                if (Object.prototype.hasOwnProperty.call(data, key)) {
                    childrenContainer.appendChild(createJsonTreeElement(data[key], key, false, newPathForChildren));
                }
            }
            item.appendChild(childrenContainer);
    
            let pressHoldTimer = null;
            let pressHoldStartX, pressHoldStartY;
    
            const toggleAction = () => {
                item.classList.toggle('expanded');
                childrenContainer.style.display = item.classList.contains('expanded') ? 'block' : 'none';
            };
    
            keySpan.addEventListener('dblclick', (e) => { 
                if (e.pointerType === 'mouse' || typeof e.pointerType === 'undefined') {
                    toggleAction();
                    e.stopPropagation(); 
                }
            });
    
            keySpan.addEventListener('pointerdown', (e) => {
                if (e.pointerType === 'touch') { 
                    pressHoldStartX = e.clientX;
                    pressHoldStartY = e.clientY;
                    clearTimeout(pressHoldTimer); 
                    pressHoldTimer = setTimeout(() => {
                        toggleAction();
                    }, 700); 
                }
            });
    
            keySpan.addEventListener('pointermove', (e) => {
                if (e.pointerType === 'touch' && pressHoldTimer) {
                    if (Math.abs(e.clientX - pressHoldStartX) > 10 || Math.abs(e.clientY - pressHoldStartY) > 10) {
                        clearTimeout(pressHoldTimer);
                    }
                }
            });
    
            keySpan.addEventListener('pointerup', (e) => {
                if (e.pointerType === 'touch') {
                    clearTimeout(pressHoldTimer);
                }
            });
    
        } else {
            const valueSpanContainer = document.createElement('span'); 
            valueSpanContainer.className = 'json-value-container';
            const valueSpan = document.createElement('span');
            valueSpan.className = 'json-value';
            let displayValue = String(data);
    
            if (typeof data === 'string') {
                displayValue = `"${data}"`; 
                if (data.length > 50) { 
                    valueSpan.textContent = `"${data.substring(0, 50)}..."`;
                    valueSpan.classList.add('json-placeholder');
                } else {
                     valueSpan.textContent = displayValue;
                }
            } else if (typeof data === 'number') {
                valueSpan.classList.add('number');
                 valueSpan.textContent = displayValue;
            } else if (typeof data === 'boolean') {
                valueSpan.classList.add('boolean');
                 valueSpan.textContent = displayValue;
            } else if (data === null) {
                valueSpan.classList.add('null');
                 valueSpan.textContent = 'null';
            } else {
                 valueSpan.textContent = displayValue;
            }
            valueSpanContainer.appendChild(valueSpan);
            item.appendChild(valueSpanContainer);
        }
        return item;
    }

    document.getElementById('importBtn').onclick = () => fileInput.click();
    document.getElementById('exportBtn').onclick = () => {
        if (currentEditorMode === 'cardEditor') {
            exportJSON();
        } else if (currentEditorMode === 'storyEditor') {
            if (exportBtn.classList.contains('disabled')) {
                 alert("Export Story is disabled. No story loaded or functionality not yet implemented for full story export.");
            } else {
                if (importedStoryData) {
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(importedStoryData, null, 2));
                    const dlAnchor = document.createElement('a');
                    dlAnchor.setAttribute("href", dataStr);
                    dlAnchor.setAttribute("download", currentFileName || 'exported_story.json');
                    dlAnchor.click();
                    alert("Story data exported successfully.");
                } else {
                    alert("No story data to export.");
                }
            }
        }
    };

    fileInput.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const jsonData = JSON.parse(ev.target.result);
                currentFileName = file.name;

                if (currentEditorMode === 'cardEditor') {
                    if (!Array.isArray(jsonData)) {
                        alert("Invalid JSON file for Card Editor: Data is not an array of cards.");
                        return;
                    }
                    const existingCardsCount = cards.length;
                    const newCards = jsonData.map((card, index) => ({
                        ...card,
                        originalIndex: existingCardsCount + index 
                    }));
                    cards = cards.concat(newCards);
                    clearEditorAndState(); 
                    renderSidebar();
                    alert(`Cards from "${file.name}" appended to workspace. Total: ${cards.length}.`);

                } else if (currentEditorMode === 'storyEditor') {
                    importedStoryData = jsonData; 
                    let storyCardsToImport = [];
                    
                    const extractCardsAndId = (obj) => {
                        let sCards = []; let sId = null;
                        if (obj && obj.storyCards && Array.isArray(obj.storyCards)) {
                            sCards = obj.storyCards; sId = obj.id || obj.shortId || null;
                        } else if (obj && obj.details && obj.details.storyCards && Array.isArray(obj.details.storyCards)) {
                            sCards = obj.details.storyCards; sId = obj.id || obj.shortId || (obj.details.scenarioId || null);
                        }
                        return { cards: sCards, id: sId ? String(sId) : null };
                    };
                    
                    let potentialCardSets = [];
                    if (jsonData.data) { 
                        if (jsonData.data.scenario) potentialCardSets.push(extractCardsAndId(jsonData.data.scenario));
                        if (jsonData.data.adventure) potentialCardSets.push(extractCardsAndId(jsonData.data.adventure));
                    } else if (Array.isArray(jsonData)) { 
                        jsonData.forEach(item => potentialCardSets.push(extractCardsAndId(item)));
                    } else { 
                        potentialCardSets.push(extractCardsAndId(jsonData));
                    }

                    potentialCardSets = potentialCardSets.filter(set => set.cards.length > 0 && set.id !== null);

                    if (potentialCardSets.length > 0) {
                        potentialCardSets.sort((a, b) => {
                            const idA = parseInt(a.id.replace(/[^0-9]/g, ''), 10); 
                            const idB = parseInt(b.id.replace(/[^0-9]/g, ''), 10);
                            if (!isNaN(idA) && !isNaN(idB)) return idB - idA;
                            return b.id.localeCompare(a.id); 
                        });
                        storyCardsToImport = potentialCardSets[0].cards; 
                        console.log("Importing story cards from ID:", potentialCardSets[0].id);
                    } else {
                         if (Array.isArray(jsonData) && jsonData.every(item => typeof item.title !== 'undefined' && (typeof item.value !== 'undefined' || typeof item.entry !== 'undefined'))) {
                            storyCardsToImport = jsonData;
                         } else if (jsonData.storyCards && Array.isArray(jsonData.storyCards)) {
                             storyCardsToImport = jsonData.storyCards;
                         }
                    }

                    if (storyCardsToImport.length > 0) {
                        cards = storyCardsToImport.map((card, index) => ({
                            title: card.title || "Untitled Card",
                            keys: card.keys || "",
                            value: card.value || card.entry || "", 
                            type: card.type || "custom",
                            description: card.description || "",
                            useForCharacterCreation: card.useForCharacterCreation || false,
                            originalIndex: index, 
                            ...card 
                        }));
                        renderSidebar(); 
                        alert(`Story "${currentFileName}" imported. ${cards.length} story cards loaded.`);
                    } else {
                        cards = [];
                        renderSidebar();
                        alert(`Story "${currentFileName}" imported, but no story cards found.`);
                    }
                    
                    if (currentStoryView === 'story') {
                        renderJsonTreeView(importedStoryData);
                        storyJsonEditor.value = "Click an item in the tree (sidebar) to view its value, or switch to 'View Cards' to see story cards.";
                    }
                    exportBtn.classList.remove('disabled'); 
                }
            } catch (error) {
                console.error("Error importing file:", error);
                alert("Invalid JSON file or error during import: " + error.message);
                importedStoryData = null; cards = [];
                renderSidebar();
                if(currentStoryView === 'story') renderJsonTreeView(null);
            } finally {
                fileInput.value = ''; 
            }
        };
        reader.readAsText(file);
    };

    function handleEditorChange() {
        if (currentEditorMode === 'cardEditor' || (currentEditorMode === 'storyEditor' && currentStoryView === 'cards')) {
            if (editorCardSource === 'workspace' && editorWorkspaceIndex !== null) {
                unsavedChangesMap.set(editorWorkspaceIndex, getEditorData());
                unsavedChangesMessage.textContent = "Unsaved Changes";
                cancelChangesBtn.style.display = 'block';
                renderSidebar(); 
            } else if (editorCardSource === 'collection' && editorCardDbId !== null) {
                unsavedChangesMessage.textContent = "Unsaved Changes"; 
                cancelChangesBtn.style.display = 'block';
                renderCollectionSidebar();
            } else if (!editorCardSource) { 
                 const editorData = getEditorData();
                if (editorData.title || editorData.value || editorData.keys || editorData.description) {
                    unsavedChangesMessage.textContent = "Unsaved Changes (New Card)";
                    cancelChangesBtn.style.display = 'block';
                } else { 
                    unsavedChangesMessage.textContent = "";
                    cancelChangesBtn.style.display = 'none';
                }
            }
        }
    }

    editTitle.addEventListener('input', handleEditorChange);
    editKeys.addEventListener('input', handleEditorChange);
    editDescription.addEventListener('input', handleEditorChange);
    valueEditor.addEventListener('input', () => {
        editorCharCount.textContent = `Character Count: ${valueEditor.value.length}`;
        handleEditorChange();
    });
    editUseForCC.addEventListener('change', handleEditorChange);
    editType.addEventListener('change', () => {
        editCustomType.style.display = (editType.value === 'custom') ? 'block' : 'none';
        if (editType.value !== 'custom') editCustomType.value = '';
        handleEditorChange();
    });
    editCustomType.addEventListener('input', handleEditorChange);

    function exportJSON() { 
        if (unsavedChangesMap.size > 0) {
            if (confirm("Workspace has unsaved changes. Exporting will include these changes. Continue?")) {
                unsavedChangesMap.forEach((changes, index) => {
                    if (cards[index]) Object.assign(cards[index], changes);
                });
                unsavedChangesMap.clear(); 
                if (sidebar.style.display === 'flex') renderSidebar(); 
            } else {
                alert("Export cancelled."); return;
            }
        }
        const cardsToExport = cards.map(card => {
            const { originalIndex, id, ...rest } = card; 
            return rest;
        });
        const sortByVal = cardSort.value;
        const sortedCardsToExport = [...cardsToExport];
        if (sortByVal === 'title') sortedCardsToExport.sort((a, b) => (a.title || "").localeCompare(b.title || ""));
        else if (sortByVal === 'type') sortedCardsToExport.sort((a, b) => (a.type || "").localeCompare(b.type || ""));
        else if (sortByVal === 'length') sortedCardsToExport.sort((a, b) => (b.value || "").length - (a.value || "").length);
        
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(sortedCardsToExport, null, 2));
        const dlAnchor = document.createElement('a');
        dlAnchor.setAttribute("href", dataStr);
        dlAnchor.setAttribute("download", currentFileName || 'story_cards.json');
        dlAnchor.click();
        alert("Workspace cards exported.");
    }

    function getVisibleCardsCount() { 
        const filterText = cardFilter.value.toLowerCase();
        if (!filterText) return cards.length;
        return cards.filter(card => {
            const title = card.title?.toLowerCase() || "";
            const type = card.type?.toLowerCase() || "";
            const value = card.value?.toLowerCase() || "";
            return title.includes(filterText) || type.includes(filterText) || value.includes(filterText);
        }).length;
    }

    function renderSidebar() { 
        const filterText = cardFilter.value.toLowerCase();
        const sortByVal = cardSort.value;
        let visibleCardsSource = cards.map((card, index) => ({ ...card, originalArrayIndexInCards: index }));

        if (filterText) {
            visibleCardsSource = visibleCardsSource.filter(cardData => {
                const card = cards[cardData.originalArrayIndexInCards]; 
                const title = card.title?.toLowerCase() || "";
                const type = card.type?.toLowerCase() || "";
                const value = card.value?.toLowerCase() || "";
                return title.includes(filterText) || type.includes(filterText) || value.includes(filterText);
            });
        }

        if (sortByVal === 'title') visibleCardsSource.sort((a, b) => (cards[a.originalArrayIndexInCards].title || "").localeCompare(cards[b.originalArrayIndexInCards].title || ""));
        else if (sortByVal === 'type') visibleCardsSource.sort((a, b) => (cards[a.originalArrayIndexInCards].type || "").localeCompare(cards[b.originalArrayIndexInCards].type || ""));
        else if (sortByVal === 'length') visibleCardsSource.sort((a, b) => (cards[b.originalArrayIndexInCards].value || "").length - (cards[a.originalArrayIndexInCards].value || "").length);
        else if (sortByVal === 'default') {
             visibleCardsSource.sort((a,b) => (cards[a.originalArrayIndexInCards].originalIndex || 0) - (cards[b.originalArrayIndexInCards].originalIndex || 0));
        }

        cardListDiv.innerHTML = '';
        visibleCardsSource.forEach(cardData => {
            const originalCardIndex = cardData.originalArrayIndexInCards;
            const card = cards[originalCardIndex]; 

            const div = document.createElement('div'); div.className = 'cardItem';
            const checkbox = document.createElement('input'); checkbox.type = 'checkbox';
            checkbox.dataset.index = originalCardIndex; 
            checkbox.checked = selectedCardIndexes.has(originalCardIndex);
            checkbox.onchange = () => {
                if (checkbox.checked) selectedCardIndexes.add(originalCardIndex);
                else selectedCardIndexes.delete(originalCardIndex);
            };
            const row = document.createElement('div'); row.className = 'cardRow';
            row.onclick = () => {
                if (currentEditorMode === 'cardEditor' || (currentEditorMode === 'storyEditor' && currentStoryView === 'cards')) {
                    editCard(originalCardIndex);
                }
            };
            const titleSpan = document.createElement('span'); titleSpan.className = 'cardTitle';
            titleSpan.textContent = card.title || "Untitled";
            if (unsavedChangesMap.has(originalCardIndex)) titleSpan.style.color = 'orange'; 
            if (editorCardSource === 'workspace' && editorWorkspaceIndex === originalCardIndex) {
                titleSpan.classList.add('active-card');
            }
            row.appendChild(titleSpan);
            if (document.getElementById('settingShowType').checked) {
                const typeSpan = document.createElement('span'); typeSpan.className = 'cardType';
                typeSpan.textContent = card.type || ""; row.appendChild(typeSpan);
            }
            if (document.getElementById('settingShowChars').checked) {
                const charsSpan = document.createElement('span'); charsSpan.className = 'cardLength';
                charsSpan.textContent = (card.value || "").length; row.appendChild(charsSpan);
            }
            div.appendChild(checkbox); div.appendChild(row); cardListDiv.appendChild(div);
        });

        if (currentEditorMode === 'cardEditor') {
            cardCountEl.textContent = `Total Cards: ${cards.length} (Showing: ${visibleCardsSource.length})`;
        } else if (currentEditorMode === 'storyEditor') {
            cardCountEl.textContent = `Total Cards: ${cards.length} (${visibleCardsSource.length})`; 
        }
        
        if (typeHeader) typeHeader.style.display = document.getElementById('settingShowType').checked ? 'inline-block' : 'none';
        if (charsHeader) charsHeader.style.display = document.getElementById('settingShowChars').checked ? 'inline-block' : 'none';
    }

    selectAllBox.addEventListener('change', (e) => {
        const checkboxes = document.querySelectorAll('#cardList input[type="checkbox"]');
        checkboxes.forEach(cb => {
            cb.checked = e.target.checked;
            const idx = parseInt(cb.dataset.index); 
            if (e.target.checked) selectedCardIndexes.add(idx);
            else selectedCardIndexes.delete(idx);
        });
    });

    function editCard(index) { 
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Card editing is not available in 'View Story' mode. Switch to 'View Cards'.");
            return;
        }
        
        editorDiv.style.display = 'flex'; 
        editorDiv.style.flexDirection = 'column'; 
        storyJsonEditor.style.display = 'none'; 

        editorCardSource = 'workspace';
        editorWorkspaceIndex = index; 
        editorCardDbId = null;       
        currentCardIndex = index; 

        const cardToDisplayInEditor = { ...cards[index] }; 
        originalCardData = { ...cards[index] };      

        if (unsavedChangesMap.has(index)) {
            const changes = unsavedChangesMap.get(index);
            Object.assign(cardToDisplayInEditor, changes); 
            unsavedChangesMessage.textContent = "Unsaved Changes";
            cancelChangesBtn.style.display = 'block';
        } else {
            unsavedChangesMessage.textContent = "";
            cancelChangesBtn.style.display = 'none';
        }

        editTitle.value = cardToDisplayInEditor.title || "";
        editKeys.value = cardToDisplayInEditor.keys || "";
        editDescription.value = cardToDisplayInEditor.description || "";
        editUseForCC.checked = cardToDisplayInEditor.useForCharacterCreation || false;
        valueEditor.value = cardToDisplayInEditor.value || "";
        editorCharCount.textContent = `Character Count: ${(cardToDisplayInEditor.value || "").length}`;
        const options = Array.from(editType.options).map(opt => opt.value);
        if (options.includes(cardToDisplayInEditor.type)) {
            editType.value = cardToDisplayInEditor.type;
            editCustomType.style.display = 'none'; editCustomType.value = '';
        } else {
            editType.value = 'custom';
            editCustomType.style.display = 'block'; editCustomType.value = cardToDisplayInEditor.type || "";
        }
        renderSidebar(); 
        if (collectionSidebar.style.display === 'flex') renderCollectionSidebar(); 
    }

    document.getElementById('cardListToggle').onclick = () => {
        const mainSidebarVisible = sidebar.style.display === 'flex';
        if (mainSidebarVisible) sidebar.style.display = 'none';
        else {
            sidebar.style.display = 'flex';
            if (currentEditorMode === 'cardEditor' || (currentEditorMode === 'storyEditor' && currentStoryView === 'cards')) renderSidebar(); 
            else if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') renderJsonTreeView(importedStoryData); 
        }
        updateMobileLayout(); 
    };

    async function saveCard() {
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Cannot save in 'View Story' mode. Switch to 'View Cards' to save individual cards.");
            return;
        }
        const editorData = getEditorData();
        if (!editorData.title && !editorData.value && !editorData.keys && !editorData.description) { 
            alert("Cannot save an empty card."); return;
        }
        if (editorCardSource === 'workspace') {
            if (editorWorkspaceIndex === null) { 
                editorData.originalIndex = cards.length; 
                cards.push(editorData);
                editorWorkspaceIndex = cards.length - 1; 
                currentCardIndex = editorWorkspaceIndex; 
                originalCardData = { ...editorData };     
                unsavedChangesMap.delete(editorWorkspaceIndex); 
                alert("New card saved to workspace.");
            } else { 
                Object.assign(cards[editorWorkspaceIndex], editorData);
                unsavedChangesMap.delete(editorWorkspaceIndex);
                originalCardData = { ...cards[editorWorkspaceIndex] }; 
                alert("Workspace card saved.");
            }
            renderSidebar(); 
        } else if (editorCardSource === 'collection') {
            if (editorCardDbId === null) { alert("Error: No collection card ID."); return; }
            try {
                const cardToUpdateInDB = { ...originalCardData, ...editorData, id: editorCardDbId };
                await db.collection.put(cardToUpdateInDB);
                originalCardData = { ...cardToUpdateInDB }; 
                alert("Collection card saved.");
                await loadCollectionCards(); 
            } catch (error) { console.error("Error saving collection card:", error); alert("Failed to save collection card."); return; }
        } else { 
            alert("Saving new card to workspace.");
            editorCardSource = 'workspace'; editorWorkspaceIndex = null;    
            await saveCard(); return; 
        }
        unsavedChangesMessage.textContent = ""; cancelChangesBtn.style.display = 'none';
        if (editorCardSource === 'workspace' && editorWorkspaceIndex !== null) editCard(editorWorkspaceIndex);
        else if (editorCardSource === 'collection' && editorCardDbId !== null) await editCollectionCard(editorCardDbId);
    }
    window.saveCard = saveCard;

    async function saveAsNewCard() {
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Action not available in 'View Story' mode."); return;
        }
        const newCardDataFromEditor = getEditorData();
        if (!newCardDataFromEditor.title && !newCardDataFromEditor.value && !newCardDataFromEditor.keys && !newCardDataFromEditor.description) {
            alert("Cannot save an empty card as new."); return;
        }
        newCardDataFromEditor.originalIndex = cards.length; 
        cards.push(newCardDataFromEditor);
        const newWorkspaceCardIndex = cards.length - 1;
        editorCardSource = 'workspace'; editorWorkspaceIndex = newWorkspaceCardIndex;
        currentCardIndex = newWorkspaceCardIndex; editorCardDbId = null; 
        originalCardData = { ...cards[editorWorkspaceIndex] }; 
        unsavedChangesMap.delete(editorWorkspaceIndex);       
        unsavedChangesMessage.textContent = ""; cancelChangesBtn.style.display = 'none';
        renderSidebar(); 
        if (collectionSidebar.style.display === 'flex') renderCollectionSidebar(); 
        editCard(editorWorkspaceIndex); 
        alert("Card saved as new to workspace.");
    }
    window.saveAsNewCard = saveAsNewCard;

    async function deleteCurrentCard() {
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Action not available in 'View Story' mode."); return;
        }
        if (!editorCardSource) {
            alert("No card loaded to delete.");
            if (editTitle.value || editKeys.value || editDescription.value || valueEditor.value) {
                if(confirm("Editor has unsaved content for a new card. Clear editor?")) clearEditorAndState();
            } return;
        }
        if (editorCardSource === 'workspace' && editorWorkspaceIndex !== null) {
            if (confirm(`Delete "${cards[editorWorkspaceIndex].title || 'Untitled'}" from workspace?`)) {
                cards.splice(editorWorkspaceIndex, 1);
                unsavedChangesMap.delete(editorWorkspaceIndex);
                const newUnsavedMap = new Map();
                unsavedChangesMap.forEach((val, key) => { if (key > editorWorkspaceIndex) newUnsavedMap.set(key - 1, val); else if (key < editorWorkspaceIndex) newUnsavedMap.set(key, val);});
                unsavedChangesMap = newUnsavedMap;
                const newSelected = new Set();
                selectedCardIndexes.forEach(idx => { if (idx > editorWorkspaceIndex) newSelected.add(idx - 1); else if (idx < editorWorkspaceIndex) newSelected.add(idx);});
                selectedCardIndexes.clear(); newSelected.forEach(idx => selectedCardIndexes.add(idx));
                clearEditorAndState(); renderSidebar(); alert("Workspace card deleted.");
            }
        } else if (editorCardSource === 'collection' && editorCardDbId !== null) {
            const cardTitleInEditor = originalCardData ? originalCardData.title : (editTitle.value || "Untitled");
            if (confirm(`Delete "${cardTitleInEditor}" from collection (permanent)?`)) {
                try {
                    await db.collection.delete(editorCardDbId);
                    clearEditorAndState(); await loadCollectionCards(); alert("Collection card deleted.");
                } catch (error) { console.error("Error deleting from collection:", error); alert("Failed to delete from collection.");}
            }
        }
    }
    window.deleteCurrentCard = deleteCurrentCard;

    function clearEditorAndState() { 
        editTitle.value = ''; editKeys.value = ''; editDescription.value = ''; valueEditor.value = '';
        editUseForCC.checked = false; editType.value = 'character'; 
        editCustomType.value = ''; editCustomType.style.display = 'none';
        editorCharCount.textContent = "Character Count: 0";
        unsavedChangesMessage.textContent = ""; cancelChangesBtn.style.display = 'none';
        editorCardSource = null; editorCardDbId = null; editorWorkspaceIndex = null; 
        currentCardIndex = null; originalCardData = null;
        if (sidebar.style.display === 'flex') {
            if (currentEditorMode === 'cardEditor' || (currentEditorMode === 'storyEditor' && currentStoryView === 'cards')) renderSidebar();
        }
        if (collectionSidebar.style.display === 'flex') renderCollectionSidebar();
    }

    function cancelChanges() {
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Action not available in 'View Story' mode."); return;
        }
        if (!editorCardSource || !originalCardData) {
            if (editTitle.value || editKeys.value || editDescription.value || valueEditor.value) {
                 if(confirm("Clear unsaved content for new card?")) clearEditorAndState();
            } else clearEditorAndState(); 
            return;
        }
        editTitle.value = originalCardData.title || ""; editKeys.value = originalCardData.keys || "";
        editDescription.value = originalCardData.description || "";
        editUseForCC.checked = originalCardData.useForCharacterCreation || false;
        valueEditor.value = originalCardData.value || "";
        editorCharCount.textContent = `Character Count: ${(originalCardData.value || "").length}`;
        const options = Array.from(editType.options).map(opt => opt.value);
        if (options.includes(originalCardData.type)) {
            editType.value = originalCardData.type;
            editCustomType.style.display = 'none'; editCustomType.value = '';
        } else {
            editType.value = 'custom';
            editCustomType.style.display = 'block'; editCustomType.value = originalCardData.type || "";
        }
        if (editorCardSource === 'workspace' && editorWorkspaceIndex !== null) {
            unsavedChangesMap.delete(editorWorkspaceIndex); renderSidebar(); 
        } else if (editorCardSource === 'collection') { 
            renderCollectionSidebar(); 
        }
        unsavedChangesMessage.textContent = ""; cancelChangesBtn.style.display = 'none';
        alert("Changes cancelled.");
        if (editorCardSource === 'workspace' && editorWorkspaceIndex !== null) editCard(editorWorkspaceIndex);
        else if (editorCardSource === 'collection' && editorCardDbId !== null) editCollectionCard(editorCardDbId);
    }
    window.cancelChanges = cancelChanges;

    function deleteSelected() { 
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Action not available in 'View Story' mode."); return;
        }
        if (selectedCardIndexes.size === 0) { alert("No cards selected in workspace."); return; }
        if (confirm(`Delete ${selectedCardIndexes.size} selected card(s) from workspace?`)) {
            const sortedIndexesToDelete = Array.from(selectedCardIndexes).sort((a, b) => b - a); 
            let editorWasAffected = false;
            sortedIndexesToDelete.forEach(index => {
                if (editorCardSource === 'workspace' && index === editorWorkspaceIndex) editorWasAffected = true; 
                cards.splice(index, 1);
                unsavedChangesMap.delete(index); 
            });
            const newUnsavedMap = new Map();
            unsavedChangesMap.forEach((val, oldKey) => {
                let newKey = oldKey;
                for (const deletedIdx of sortedIndexesToDelete) if (oldKey > deletedIdx) newKey--;
                if (newKey >= 0 && !sortedIndexesToDelete.includes(oldKey) ) newUnsavedMap.set(newKey, val);
            });
            unsavedChangesMap = newUnsavedMap;
            if (editorWasAffected) clearEditorAndState();
            else if (editorCardSource === 'workspace' && editorWorkspaceIndex !== null) {
                let shifts = 0;
                sortedIndexesToDelete.forEach(deletedIdx => { if (editorWorkspaceIndex > deletedIdx) shifts++; });
                editorWorkspaceIndex -= shifts; currentCardIndex = editorWorkspaceIndex; 
            }
            selectedCardIndexes.clear(); selectAllBox.checked = false;
            renderSidebar(); alert(`${sortedIndexesToDelete.length} card(s) deleted.`);
        }
    }
    window.deleteSelected = deleteSelected;

    function assignTypeSelected() { 
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Action not available in 'View Story' mode."); return;
        }
        if (selectedCardIndexes.size === 0) { alert("No cards selected in workspace."); return; }
        const newAssignedType = prompt("Enter type for selected workspace cards:"); 
        if (newAssignedType && newAssignedType.trim() !== "") {
            let changedCount = 0;
            selectedCardIndexes.forEach(index => {
                if (cards[index]) {
                    cards[index].type = newAssignedType.trim();
                    if (editorCardSource === 'workspace' && index === editorWorkspaceIndex) { 
                        originalCardData.type = newAssignedType.trim(); 
                        editCard(editorWorkspaceIndex); 
                    } changedCount++;
                }
            });
            if (changedCount > 0) { alert(`Type "${newAssignedType.trim()}" assigned to ${changedCount} card(s).`); renderSidebar(); }
        } else if (newAssignedType !== null) alert("Type cannot be empty.");
    }
    window.assignTypeSelected = assignTypeSelected;

    window.addSelectedWorkspaceCardsToCollection = async function() {
        if (currentEditorMode === 'storyEditor' && currentStoryView === 'story') {
            alert("Action not available in 'View Story' mode."); return;
        }
        if (selectedCardIndexes.size === 0) { alert("No cards selected to add to collection."); return; }
        let addedCount = 0; let cardTitlesAdded = [];
        const indexesToAdd = Array.from(selectedCardIndexes);
        for (const index of indexesToAdd) {
            if (cards[index]) {
                const workspaceCardCopy = { ...cards[index] }; let cardToCollect;
                if (unsavedChangesMap.has(index)) {
                    const changes = unsavedChangesMap.get(index);
                    if(confirm(`Card "${workspaceCardCopy.title || 'Untitled'}" has unsaved changes. Add version with changes to collection? (Cancel to skip)`)){
                        cardToCollect = { ...workspaceCardCopy, ...changes };
                    } else continue; 
                } else cardToCollect = workspaceCardCopy;
                delete cardToCollect.originalArrayIndexInCards; delete cardToCollect.id; 
                await addCardToCollection(cardToCollect); 
                addedCount++; cardTitlesAdded.push(cardToCollect.title || "Untitled");
            }
        }
        if (addedCount > 0) {
            alert(`Added ${addedCount} card(s) to collection: ${cardTitlesAdded.join(", ")}`);
            if (collectionSidebar.style.display === 'flex') await loadCollectionCards(); 
        } else if (indexesToAdd.length > 0) alert("No cards added (all skipped/cancelled).");
    }

    async function loadCollectionCards() {
        try {
            collectionCards = await db.collection.orderBy('originalIndex').toArray(); 
            renderCollectionSidebar();
        } catch (error) { console.error("Error loading collection:", error); alert("Could not load collection."); }
    }

    async function addCardToCollection(cardData) { 
        try {
            const cardToAdd = { ...cardData }; delete cardToAdd.id; 
            const lastCard = await db.collection.orderBy('originalIndex').last();
            cardToAdd.originalIndex = (lastCard && typeof lastCard.originalIndex === 'number') ? lastCard.originalIndex + 1 : 0;
            await db.collection.add(cardToAdd);
        } catch (error) { console.error("Error adding to collection DB:", error); throw error; }
    }

    async function editCollectionCard(dbId) { 
        if (currentEditorMode === 'storyEditor') {
            alert("Edit collection cards in 'Card Editor' mode."); return;
        }
        try {
            const cardFromColl = await db.collection.get(dbId);
            if (!cardFromColl) { alert("Card not found in collection."); return; }
            editorDiv.style.display = 'flex'; editorDiv.style.flexDirection = 'column';
            storyJsonEditor.style.display = 'none'; 
            editorCardSource = 'collection'; editorCardDbId = dbId;
            editorWorkspaceIndex = null; currentCardIndex = null;    
            originalCardData = { ...cardFromColl }; 
            unsavedChangesMessage.textContent = ""; cancelChangesBtn.style.display = 'none';
            editTitle.value = cardFromColl.title || ""; editKeys.value = cardFromColl.keys || "";
            editDescription.value = cardFromColl.description || "";
            editUseForCC.checked = cardFromColl.useForCharacterCreation || false;
            valueEditor.value = cardFromColl.value || "";
            editorCharCount.textContent = `Character Count: ${(cardFromColl.value || "").length}`;
            const options = Array.from(editType.options).map(opt => opt.value);
            if (options.includes(cardFromColl.type)) {
                editType.value = cardFromColl.type;
                editCustomType.style.display = 'none'; editCustomType.value = '';
            } else {
                editType.value = 'custom';
                editCustomType.style.display = 'block'; editCustomType.value = cardFromColl.type || "";
            }
            renderCollectionSidebar(); 
            if (sidebar.style.display === 'flex') renderSidebar(); 
        } catch (error) { console.error("Error loading collection card to editor:", error); alert("Failed to load collection card."); }
    }
    window.editCollectionCard = editCollectionCard;

    function renderCollectionSidebar() {
        const filterText = collectionCardFilter.value.toLowerCase();
        const sortByVal = collectionCardSort.value;
        let visibleCollCards = [...collectionCards]; 
        if (filterText) {
            visibleCollCards = visibleCollCards.filter(card => {
                const title = card.title?.toLowerCase() || ""; const type = card.type?.toLowerCase() || "";
                const value = card.value?.toLowerCase() || "";
                return title.includes(filterText) || type.includes(filterText) || value.includes(filterText);
            });
        }
        if (sortByVal === 'title') visibleCollCards.sort((a, b) => (a.title || "").localeCompare(b.title || ""));
        else if (sortByVal === 'type') visibleCollCards.sort((a, b) => (a.type || "").localeCompare(b.type || ""));
        else if (sortByVal === 'length') visibleCollCards.sort((a, b) => (b.value || "").length - (a.value || "").length);
        else if (sortByVal === 'default') visibleCollCards.sort((a, b) => (a.originalIndex || 0) - (b.originalIndex || 0) || (a.id || 0) - (b.id || 0));
        
        collectionCardListDiv.innerHTML = '';
        visibleCollCards.forEach(card => {
            const div = document.createElement('div'); div.className = 'cardItem';
            const checkbox = document.createElement('input'); checkbox.type = 'checkbox';
            checkbox.dataset.id = card.id; 
            checkbox.checked = selectedCollectionCardDBIds.has(card.id);
            checkbox.onchange = () => { if (checkbox.checked) selectedCollectionCardDBIds.add(card.id); else selectedCollectionCardDBIds.delete(card.id); };
            const row = document.createElement('div'); row.className = 'cardRow';
            row.onclick = () => { if (currentEditorMode === 'cardEditor') editCollectionCard(card.id); else alert("Switch to 'Card Editor' mode to edit collection cards."); };
            const titleSpan = document.createElement('span'); titleSpan.className = 'cardTitle';
            titleSpan.textContent = card.title || "Untitled";
            if (editorCardSource === 'collection' && editorCardDbId === card.id) titleSpan.classList.add('active-card');
            row.appendChild(titleSpan);
            if (document.getElementById('settingShowType').checked) {
                const typeSpan = document.createElement('span'); typeSpan.className = 'cardType';
                typeSpan.textContent = card.type || ""; row.appendChild(typeSpan);
            }
            if (document.getElementById('settingShowChars').checked) {
                const charsSpan = document.createElement('span'); charsSpan.className = 'cardLength';
                charsSpan.textContent = (card.value || "").length; row.appendChild(charsSpan);
            }
            div.appendChild(checkbox); div.appendChild(row); collectionCardListDiv.appendChild(div);
        });
        collectionCardCountEl.textContent = `Total Collection: ${collectionCards.length} (Showing: ${visibleCollCards.length})`;
        if(collectionTypeHeader) collectionTypeHeader.style.display = document.getElementById('settingShowType').checked ? 'inline-block' : 'none';
        if(collectionCharsHeader) collectionCharsHeader.style.display = document.getElementById('settingShowChars').checked ? 'inline-block' : 'none';
    }

    collectionToggleBtn.onclick = () => {
        const collVisible = collectionSidebar.style.display === 'flex';
        if (collVisible) collectionSidebar.style.display = 'none';
        else { collectionSidebar.style.display = 'flex'; loadCollectionCards(); }
        updateMobileLayout(); 
    };
    collectionCardFilter.addEventListener('input', renderCollectionSidebar);
    collectionCardSort.addEventListener('change', renderCollectionSidebar);
    collectionSelectAllBox.addEventListener('change', (e) => {
        const checkboxes = document.querySelectorAll('#collectionCardList input[type="checkbox"]');
        checkboxes.forEach(cb => {
            const card_id = parseInt(cb.dataset.id); 
            cb.checked = e.target.checked;
            if (e.target.checked) selectedCollectionCardDBIds.add(card_id);
            else selectedCollectionCardDBIds.delete(card_id);
        });
    });

    window.deleteSelectedFromCollection = async function() {
        if (selectedCollectionCardDBIds.size === 0) { alert("No cards selected from collection to delete."); return; }
        if (confirm(`Permanently delete ${selectedCollectionCardDBIds.size} card(s) from collection?`)) {
            try {
                let editorAffected = false;
                Array.from(selectedCollectionCardDBIds).forEach(id => { if(editorCardSource === 'collection' && editorCardDbId === id) editorAffected = true; });
                await db.collection.bulkDelete(Array.from(selectedCollectionCardDBIds));
                selectedCollectionCardDBIds.clear(); collectionSelectAllBox.checked = false;
                if(editorAffected) clearEditorAndState();
                await loadCollectionCards(); 
                alert("Selected card(s) deleted from collection.");
            } catch (error) { console.error("Error deleting from collection:", error); alert("Failed to delete from collection."); }
        }
    }

    window.addSelectedToWorkspace = async function() {
        if (currentEditorMode === 'storyEditor') {
            if (!confirm("Replace current story cards with selected collection cards? This action cannot be undone for the current story cards list.")) return;
             cards = []; 
        }
        if (selectedCollectionCardDBIds.size === 0) { alert("No cards selected from collection."); return; }
        try {
            const cardsFromDb = await db.collection.bulkGet(Array.from(selectedCollectionCardDBIds));
            let addedCount = 0;
            cardsFromDb.forEach(collCard => {
                if (collCard) {
                    const workspaceCard = { ...collCard };
                    delete workspaceCard.id; delete workspaceCard.originalIndex; 
                    workspaceCard.originalIndex = cards.length; 
                    cards.push(workspaceCard); addedCount++;
                }
            });
            if (addedCount > 0) {
                if (sidebar.style.display === 'flex') renderSidebar(); 
                alert(`Added ${addedCount} card(s) to workspace/story.`);
            }
        } catch (error) { console.error("Error adding to workspace:", error); alert("Failed to add cards."); }
    }

    window.importCollectionJSON = async function() {
        if (currentEditorMode === 'storyEditor') {
             alert("Collection management is for 'Card Editor' mode."); return;
        }
        if (confirm("Importing will OVERWRITE current collection. Continue?")) {
            collectionFileInput.onchange = async (e) => {
                const file = e.target.files[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    try {
                        const importedData = JSON.parse(ev.target.result);
                        if (!Array.isArray(importedData)) { alert("Invalid JSON: Not an array."); return; }
                        await db.transaction('rw', db.collection, async () => {
                            await db.collection.clear(); 
                            const collectionToAdd = importedData.map((card, index) => {
                                const { id, ...rest } = card; 
                                return { ...rest, originalIndex: index };
                            });
                            await db.collection.bulkAdd(collectionToAdd);
                        });
                        if (editorCardSource === 'collection') clearEditorAndState();
                        await loadCollectionCards();
                        alert(`Collection imported from "${file.name}", overwriting previous.`);
                    } catch (err) { console.error("Err import collection:", err); alert("Invalid JSON or import error."); } 
                    finally { collectionFileInput.value = ''; }
                };
                reader.readAsText(file);
            };
            collectionFileInput.click();
        }
    }

    window.exportCollectionJSON = async function() {
         if (currentEditorMode === 'storyEditor') {
             alert("Collection management is for 'Card Editor' mode."); return;
        }
        try {
            const allCollCardsRaw = await db.collection.orderBy('originalIndex').toArray();
            if (allCollCardsRaw.length === 0) { alert("Collection is empty."); return; }
            const cardsToExport = allCollCardsRaw.map(card => {
                 const { id, originalIndex, ...rest } = card; return rest;                                 
            });
            const sortByVal = collectionCardSort.value; 
            const sortedCardsToExport = [...cardsToExport];
            if (sortByVal === 'title') sortedCardsToExport.sort((a,b) => (a.title||"").localeCompare(b.title||""));
            else if (sortByVal === 'type') sortedCardsToExport.sort((a,b) => (a.type||"").localeCompare(b.type||""));
            else if (sortByVal === 'length') sortedCardsToExport.sort((a,b) => (b.value||"").length - (a.value||"").length);
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(sortedCardsToExport, null, 2));
            const dlAnchor = document.createElement('a');
            dlAnchor.setAttribute("href", dataStr);
            dlAnchor.setAttribute("download", "story_card_collection.json");
            dlAnchor.click(); alert("Collection exported.");
        } catch (err) { console.error("Err export collection:", err); alert("Failed to export collection."); }
    }

    document.getElementById('settingsBtn').onclick = () => toggleSettings(true);
    document.getElementById('settingsOverlay').addEventListener('click', (e) => {
        if (e.target.id === 'settingsOverlay') toggleSettings(false);
    });
    function toggleSettings(show) {
        document.getElementById('settingsOverlay').style.display = show ? 'flex' : 'none';
    }

    window.saveSettings = function() {
        const sidebarFont = document.getElementById('sidebarFont').value + 'px';
        const editorFont = document.getElementById('editorFont').value + 'px';
        const charFont = document.getElementById('charFont').value + 'px';
        const typeFont = document.getElementById('typeFont').value + 'px';
        const jsonTreeFont = document.getElementById('jsonTreeFont').value + 'px'; 
        const showChars = document.getElementById('settingShowChars').checked;
        const showType = document.getElementById('settingShowType').checked;
        const tapToClose = document.getElementById('settingTapToClose').checked;

        document.documentElement.style.setProperty('--sidebar-font-size', sidebarFont);
        document.documentElement.style.setProperty('--editor-font-size', editorFont);
        document.documentElement.style.setProperty('--char-font-size', charFont);
        document.documentElement.style.setProperty('--type-font-size', typeFont);
        document.documentElement.style.setProperty('--json-tree-font-size', jsonTreeFont); 

        localStorage.setItem('sidebarFontSize', sidebarFont);
        localStorage.setItem('editorFontSize', editorFont);
        localStorage.setItem('charFontSize', charFont);
        localStorage.setItem('typeFontSize', typeFont);
        localStorage.setItem('jsonTreeFontSize', jsonTreeFont); 
        localStorage.setItem('showChars', String(showChars));
        localStorage.setItem('showType', String(showType));
        localStorage.setItem('tapToCloseSidebar', String(tapToClose));

        toggleSettings(false);
        window.loadSettings(); 
        if (sidebar.style.display === 'flex' && (currentEditorMode === 'cardEditor' || (currentEditorMode==='storyEditor' && currentStoryView === 'cards') )) {
             renderSidebar();
        }
        if (collectionSidebar.style.display === 'flex') renderCollectionSidebar();
    }

    window.loadSettings = function() {
        const sidebarFont = localStorage.getItem('sidebarFontSize') || '14px';
        const editorFont = localStorage.getItem('editorFontSize') || '14px';
        const charFont = localStorage.getItem('charFontSize') || '14px';
        const typeFont = localStorage.getItem('typeFontSize') || '14px';
        const jsonTreeFont = localStorage.getItem('jsonTreeFontSize') || '12px'; 
        const showChars = localStorage.getItem('showChars') !== 'false'; 
        const showType = localStorage.getItem('showType') !== 'false';   
        const tapToClose = localStorage.getItem('tapToCloseSidebar') === 'true'; 

        document.documentElement.style.setProperty('--sidebar-font-size', sidebarFont);
        document.documentElement.style.setProperty('--editor-font-size', editorFont);
        document.documentElement.style.setProperty('--char-font-size', charFont);
        document.documentElement.style.setProperty('--type-font-size', typeFont);
        document.documentElement.style.setProperty('--json-tree-font-size', jsonTreeFont); 

        document.getElementById('sidebarFont').value = parseInt(sidebarFont);
        document.getElementById('editorFont').value = parseInt(editorFont);
        document.getElementById('charFont').value = parseInt(charFont);
        document.getElementById('typeFont').value = parseInt(typeFont);
        document.getElementById('jsonTreeFont').value = parseInt(jsonTreeFont); 
        document.getElementById('settingShowChars').checked = showChars;
        document.getElementById('settingShowType').checked = showType;
        document.getElementById('settingTapToClose').checked = tapToClose;

        if(typeHeader) typeHeader.style.display = showType ? 'inline-block' : 'none';
        if(charsHeader) charsHeader.style.display = showChars ? 'inline-block' : 'none';
        if(collectionTypeHeader) collectionTypeHeader.style.display = showType ? 'inline-block' : 'none';
        if(collectionCharsHeader) collectionCharsHeader.style.display = showChars ? 'inline-block' : 'none';
    }

    document.getElementById('main').addEventListener('click', (e) => {
        const tapToCloseEnabled = document.getElementById('settingTapToClose').checked;
        if (tapToCloseEnabled && window.innerWidth <= 768) { 
            let updatedLayout = false;
            if (sidebar.style.display === 'flex' && !sidebar.contains(e.target) && e.target.id !== 'cardListToggle' && !e.target.closest('#header')) {
                sidebar.style.display = 'none'; updatedLayout = true;
            }
            if (collectionSidebar.style.display === 'flex' && !collectionSidebar.contains(e.target) && e.target.id !== 'collectionToggleBtn' && !e.target.closest('#header')) {
                collectionSidebar.style.display = 'none'; updatedLayout = true;
            }
            if (updatedLayout) updateMobileLayout();
        }
    });
    
    cardFilter.addEventListener('input', renderSidebar);
    cardSort.addEventListener('change', renderSidebar);

    window.addEventListener('resize', updateMobileLayout);
    window.addEventListener('load', () => {
        updateMobileLayout(); 
    });

    window.loadSettings(); 
    clearEditorAndState(); 
    updateUIForCardEditorMode(); 
    renderSidebar(); 
    
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('service-worker.js')
          .then(reg => console.log('SW registered:', reg))
          .catch(err => console.error('SW reg failed:', err));
      }
  </script>
</body>
</html>
